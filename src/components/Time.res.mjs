// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function useTypedCharactersString(delayOpt, string) {
  var delay = delayOpt !== undefined ? delayOpt : 25;
  var match = React.useState(function () {
        return 0;
      });
  var setRevealedCharCount = match[1];
  var revealedCharCount = match[0];
  var match$1 = React.useState(function () {
        
      });
  var setOptIntervalId = match$1[1];
  var optIntervalId = match$1[0];
  React.useEffect((function () {
          Core__Option.map(optIntervalId, (function (intervalId) {
                  if (revealedCharCount >= string.length) {
                    clearInterval(intervalId);
                    return ;
                  }
                  
                }));
        }), [
        optIntervalId,
        revealedCharCount,
        string,
        delay
      ]);
  React.useEffect((function () {
          setRevealedCharCount(function (param) {
                return 0;
              });
          var intervalId = setInterval((function () {
                  setRevealedCharCount(function (prevCount) {
                        return prevCount + 1 | 0;
                      });
                }), delay);
          setOptIntervalId(function (param) {
                return Caml_option.some(intervalId);
              });
          return (function () {
                    clearInterval(intervalId);
                  });
        }), [
        delay,
        string
      ]);
  return string.substr(0, revealedCharCount);
}

function useRotatingCharacterAnimation(delayOpt, string) {
  var delay = delayOpt !== undefined ? delayOpt : 25;
  var match = React.useState(function () {
        return 0;
      });
  var setIndex = match[1];
  var index = match[0];
  var match$1 = React.useState(function () {
        return string.charAt(index);
      });
  var setCharToShow = match$1[1];
  var stringLength = string.length;
  var match$2 = React.useState(function () {
        
      });
  var setOptIntervalId = match$2[1];
  React.useEffect((function () {
          var intervalId = setInterval((function () {
                  setIndex(function (index) {
                        var inc = index + 1 | 0;
                        setCharToShow(function (param) {
                              return string.charAt(Caml_int32.mod_(inc, stringLength));
                            });
                        return inc;
                      });
                }), delay);
          setOptIntervalId(function (param) {
                return Caml_option.some(intervalId);
              });
          return (function () {
                    clearInterval(intervalId);
                  });
        }), [
        delay,
        string
      ]);
  return match$1[0];
}

function Time$DelayedDisplay(props) {
  var __tempDisplay = props.tempDisplay;
  var __delay = props.delay;
  var delay = __delay !== undefined ? __delay : 1000;
  var tempDisplay = __tempDisplay !== undefined ? Caml_option.valFromOption(__tempDisplay) : null;
  var match = React.useState(function () {
        return false;
      });
  var setShow = match[1];
  React.useEffect((function () {
          var timeout = setTimeout((function () {
                  setShow(function (param) {
                        return true;
                      });
                }), delay);
          return (function () {
                    clearTimeout(timeout);
                  });
        }), []);
  if (match[0]) {
    return props.children;
  } else {
    return tempDisplay;
  }
}

var DelayedDisplay = {
  make: Time$DelayedDisplay
};

function Time$RepeatDisplay(props) {
  var delay = props.delay;
  var match = React.useState(function () {
        return false;
      });
  var setShow = match[1];
  React.useEffect((function () {
          var intervalId = setInterval((function () {
                  setShow(function (param) {
                        return true;
                      });
                }), delay);
          var intervalIdForFlashRender = setInterval((function () {
                  setShow(function (param) {
                        return false;
                      });
                }), delay + 100 | 0);
          return (function () {
                    clearInterval(intervalId);
                    clearInterval(intervalIdForFlashRender);
                  });
        }), []);
  if (match[0]) {
    return null;
  } else {
    return props.children;
  }
}

var RepeatDisplay = {
  make: Time$RepeatDisplay
};

function useDelayedState(delayOpt, functionSetter, state) {
  var delay = delayOpt !== undefined ? delayOpt : 1000;
  React.useEffect((function () {
          var timeout = setTimeout((function () {
                  functionSetter(function (param) {
                        return state;
                      });
                }), delay);
          return (function () {
                    clearTimeout(timeout);
                  });
        }), []);
}

function useInterval(callback, delay) {
  var savedCallback = React.useRef(callback);
  React.useEffect((function () {
          savedCallback.current = callback;
        }), [callback]);
  React.useEffect((function () {
          var id = setInterval(savedCallback.current, delay);
          return (function () {
                    clearInterval(id);
                  });
        }), [delay]);
}

export {
  useTypedCharactersString ,
  useRotatingCharacterAnimation ,
  DelayedDisplay ,
  RepeatDisplay ,
  useDelayedState ,
  useInterval ,
}
/* react Not a pure module */
